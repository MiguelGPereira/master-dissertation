print(e)
exception <- TRUE
}
}, finally = {})
if( !inherits(result, "error") || (inherits(result, "error") && exception) ){
break()
}
}
}
}
}
### FOR ELECTIONS
# is2Years <- 1
# maxPairs <<- 2
# minSupport <<- 1
# dataset <- NULL
# X <- x
# Y <- y
# # invoke miner
# if(is2Years){
#   mineRules(X, Y, is2Years, xs = xs, ys = ys)
# } else {
#   # KFold Cross Validation
#   # Randomly shuffle the data
#   set.seed(randomSeed)
#   samplerows <- sample(nrow(X))
#   X <- X[samplerows, ]
#   Y <- Y[samplerows, ]
#
#   # Create K equally size folds
#   folds <- cut(seq(1, nrow(X)), breaks = Kfolds, labels = FALSE)
#
#   # Perform K fold cross validation
#   mineRules(X, Y, folds = folds, Kfolds = Kfolds)
#
# }
# CORE SCRIPT
isGrid <- F
args = commandArgs(trailingOnly=TRUE)
if (length(args)==1) {
if (args[1] == "grid"){
isGrid <- T
}
}
# dependencies
if (isGrid) {
library("carenR",lib.loc="/homes/up201402671/data/R/lib")
library(arules, lib.loc="/homes/up201402671/data/R/lib")
source("caren_integrated.R")
} else {
require("carenR")
library(arules)
}
source("LRAR/caren.R")
source("LRAR/predictLRAR.R")
source("edira/edira.R")
source("miner.R")
# configurations
isPairwise <- 1
Kfolds <- 10
randomSeed <- 1234
minConfidence <- 70
baseMinSupport <- 1
confThreshold <- 0.05
minLift <- 0
minImprovment <- -1
#load("german2005.RDATA")
#load("german2009.RDATA")
#load("german2005_2009.RDATA")
#load("portugal2009.RDATA")
#load("portugal2013.RDATA")
#load("portugal2009_2013.RDATA")
#load("portugal2013_2017.RDATA")
#load("portugal2013_2017_complete.RDATA")
#datasets <- list("authorship","bodyfat","calhousing","cpu-small","elevators","fried","glass","housing","iris","pendigits","segment","stock","vehicle","vowel","wine","wisconsin")
datasets <- list("bodyfat")
### FOR DATASETS
for(dataset in datasets) {
if (isGrid) {
load(paste("/homes/up201402671/data/master-dissertation/R/label_ranking_data/",dataset,".RData", sep = ""))
} else {
load(paste("label_ranking_data/",dataset,".RDATA", sep = ""))
}
is2Years <- 0
X <- x
Y <- y
# Randomly shuffle the data
set.seed(randomSeed)
samplerows <- sample(nrow(X))
X <- X[samplerows, ]
Y <- Y[samplerows, ]
pairsLimit <- if(ncol(Y) < 4) ncol(Y) else 4
for(mpairs in 3:3){
maxPairs <<- mpairs
minSupport <<- baseMinSupport
# invoke miner
if(is2Years){
mineRules(X, Y, is2Years, xs = xs, ys = ys)
} else {
# KFold Cross Validation
# Create K equally size folds
folds <- cut(seq(1, nrow(X)), breaks = Kfolds, labels = FALSE)
# Perform K fold cross validation
#mineRules(X, Y, folds = folds, Kfolds = Kfolds)
repeat{
exception <- FALSE
result = tryCatch({
mineRules(X, Y, folds = folds, Kfolds = Kfolds)
}, error = function(e) {
#if(e$message == "subscript out of bounds" &&  e$call == "FUN(X[[i]], ...)"){
if(e$message == "no rules"){
if(minSupport == 1) {
print("#no rules found!")
exception <- TRUE
} else {
print(paste("#no rules found - decreasing support from ",minSupport," to ",minSupport - 5))
minSupport <<- minSupport - 5
e
}
} else if(e$message == "non zero def.rank"){
print(paste("#def.rank can be optimized - decreasing support from ",minSupport," to ",minSupport - 5))
minSupport <<- minSupport - 5
e
} else {
print("#error")
print(e)
exception <- TRUE
}
}, finally = {})
if( !inherits(result, "error") || (inherits(result, "error") && exception) ){
break()
}
}
}
}
}
### FOR ELECTIONS
# is2Years <- 1
# maxPairs <<- 2
# minSupport <<- 1
# dataset <- NULL
# X <- x
# Y <- y
# # invoke miner
# if(is2Years){
#   mineRules(X, Y, is2Years, xs = xs, ys = ys)
# } else {
#   # KFold Cross Validation
#   # Randomly shuffle the data
#   set.seed(randomSeed)
#   samplerows <- sample(nrow(X))
#   X <- X[samplerows, ]
#   Y <- Y[samplerows, ]
#
#   # Create K equally size folds
#   folds <- cut(seq(1, nrow(X)), breaks = Kfolds, labels = FALSE)
#
#   # Perform K fold cross validation
#   mineRules(X, Y, folds = folds, Kfolds = Kfolds)
#
# }
rulzList[[kfold]]
# CORE SCRIPT
isGrid <- F
args = commandArgs(trailingOnly=TRUE)
if (length(args)==1) {
if (args[1] == "grid"){
isGrid <- T
}
}
# dependencies
if (isGrid) {
library("carenR",lib.loc="/homes/up201402671/data/R/lib")
library(arules, lib.loc="/homes/up201402671/data/R/lib")
source("caren_integrated.R")
} else {
require("carenR")
library(arules)
}
source("LRAR/caren.R")
source("LRAR/predictLRAR.R")
source("edira/edira.R")
source("miner.R")
# configurations
isPairwise <- 1
Kfolds <- 10
randomSeed <- 1234
minConfidence <- 70
baseMinSupport <- 1
confThreshold <- 0.05
minLift <- 0
minImprovment <- -1
#load("german2005.RDATA")
#load("german2009.RDATA")
#load("german2005_2009.RDATA")
#load("portugal2009.RDATA")
#load("portugal2013.RDATA")
#load("portugal2009_2013.RDATA")
#load("portugal2013_2017.RDATA")
#load("portugal2013_2017_complete.RDATA")
#datasets <- list("authorship","bodyfat","calhousing","cpu-small","elevators","fried","glass","housing","iris","pendigits","segment","stock","vehicle","vowel","wine","wisconsin")
datasets <- list("bodyfat")
### FOR DATASETS
for(dataset in datasets) {
if (isGrid) {
load(paste("/homes/up201402671/data/master-dissertation/R/label_ranking_data/",dataset,".RData", sep = ""))
} else {
load(paste("label_ranking_data/",dataset,".RDATA", sep = ""))
}
is2Years <- 0
X <- x
Y <- y
# Randomly shuffle the data
set.seed(randomSeed)
samplerows <- sample(nrow(X))
X <- X[samplerows, ]
Y <- Y[samplerows, ]
pairsLimit <- if(ncol(Y) < 4) ncol(Y) else 4
for(mpairs in 3:3){
maxPairs <<- mpairs
minSupport <<- baseMinSupport
# invoke miner
if(is2Years){
mineRules(X, Y, is2Years, xs = xs, ys = ys)
} else {
# KFold Cross Validation
# Create K equally size folds
folds <- cut(seq(1, nrow(X)), breaks = Kfolds, labels = FALSE)
# Perform K fold cross validation
#mineRules(X, Y, folds = folds, Kfolds = Kfolds)
repeat{
exception <- FALSE
result = tryCatch({
mineRules(X, Y, folds = folds, Kfolds = Kfolds)
}, error = function(e) {
#if(e$message == "subscript out of bounds" &&  e$call == "FUN(X[[i]], ...)"){
if(e$message == "no rules"){
if(minSupport == 1) {
print("#no rules found!")
exception <- TRUE
} else {
print(paste("#no rules found - decreasing support from ",minSupport," to ",minSupport - 5))
minSupport <<- minSupport - 5
e
}
} else if(e$message == "non zero def.rank"){
print(paste("#def.rank can be optimized - decreasing support from ",minSupport," to ",minSupport - 5))
minSupport <<- minSupport - 5
e
} else {
print("#error")
print(e)
exception <- TRUE
}
}, finally = {})
if( !inherits(result, "error") || (inherits(result, "error") && exception) ){
break()
}
}
}
}
}
### FOR ELECTIONS
# is2Years <- 1
# maxPairs <<- 2
# minSupport <<- 1
# dataset <- NULL
# X <- x
# Y <- y
# # invoke miner
# if(is2Years){
#   mineRules(X, Y, is2Years, xs = xs, ys = ys)
# } else {
#   # KFold Cross Validation
#   # Randomly shuffle the data
#   set.seed(randomSeed)
#   samplerows <- sample(nrow(X))
#   X <- X[samplerows, ]
#   Y <- Y[samplerows, ]
#
#   # Create K equally size folds
#   folds <- cut(seq(1, nrow(X)), breaks = Kfolds, labels = FALSE)
#
#   # Perform K fold cross validation
#   mineRules(X, Y, folds = folds, Kfolds = Kfolds)
#
# }
# CORE SCRIPT
isGrid <- F
args = commandArgs(trailingOnly=TRUE)
if (length(args)==1) {
if (args[1] == "grid"){
isGrid <- T
}
}
# dependencies
if (isGrid) {
library("carenR",lib.loc="/homes/up201402671/data/R/lib")
library(arules, lib.loc="/homes/up201402671/data/R/lib")
source("caren_integrated.R")
} else {
require("carenR")
library(arules)
}
source("LRAR/caren.R")
source("LRAR/predictLRAR.R")
source("edira/edira.R")
source("miner.R")
# configurations
isPairwise <- 1
Kfolds <- 10
randomSeed <- 1234
minConfidence <- 70
baseMinSupport <- 1
confThreshold <- 0.05
minLift <- 0
minImprovment <- -1
#load("german2005.RDATA")
#load("german2009.RDATA")
#load("german2005_2009.RDATA")
#load("portugal2009.RDATA")
#load("portugal2013.RDATA")
#load("portugal2009_2013.RDATA")
#load("portugal2013_2017.RDATA")
#load("portugal2013_2017_complete.RDATA")
#datasets <- list("authorship","bodyfat","calhousing","cpu-small","elevators","fried","glass","housing","iris","pendigits","segment","stock","vehicle","vowel","wine","wisconsin")
datasets <- list("bodyfat")
### FOR DATASETS
for(dataset in datasets) {
if (isGrid) {
load(paste("/homes/up201402671/data/master-dissertation/R/label_ranking_data/",dataset,".RData", sep = ""))
} else {
load(paste("label_ranking_data/",dataset,".RDATA", sep = ""))
}
is2Years <- 0
X <- x
Y <- y
# Randomly shuffle the data
set.seed(randomSeed)
samplerows <- sample(nrow(X))
X <- X[samplerows, ]
Y <- Y[samplerows, ]
pairsLimit <- if(ncol(Y) < 4) ncol(Y) else 4
for(mpairs in 3:3){
maxPairs <<- mpairs
minSupport <<- baseMinSupport
# invoke miner
if(is2Years){
mineRules(X, Y, is2Years, xs = xs, ys = ys)
} else {
# KFold Cross Validation
# Create K equally size folds
folds <- cut(seq(1, nrow(X)), breaks = Kfolds, labels = FALSE)
# Perform K fold cross validation
#mineRules(X, Y, folds = folds, Kfolds = Kfolds)
repeat{
exception <- FALSE
result = tryCatch({
mineRules(X, Y, folds = folds, Kfolds = Kfolds)
}, error = function(e) {
#if(e$message == "subscript out of bounds" &&  e$call == "FUN(X[[i]], ...)"){
if(e$message == "no rules"){
if(minSupport == 1) {
print("#no rules found!")
exception <- TRUE
} else {
print(paste("#no rules found - decreasing support from ",minSupport," to ",minSupport - 5))
minSupport <<- minSupport - 5
e
}
} else if(e$message == "non zero def.rank"){
print(paste("#def.rank can be optimized - decreasing support from ",minSupport," to ",minSupport - 5))
minSupport <<- minSupport - 5
e
} else {
print("#error")
print(e)
exception <- TRUE
}
}, finally = {})
if( !inherits(result, "error") || (inherits(result, "error") && exception) ){
break()
}
}
}
}
}
### FOR ELECTIONS
# is2Years <- 1
# maxPairs <<- 2
# minSupport <<- 1
# dataset <- NULL
# X <- x
# Y <- y
# # invoke miner
# if(is2Years){
#   mineRules(X, Y, is2Years, xs = xs, ys = ys)
# } else {
#   # KFold Cross Validation
#   # Randomly shuffle the data
#   set.seed(randomSeed)
#   samplerows <- sample(nrow(X))
#   X <- X[samplerows, ]
#   Y <- Y[samplerows, ]
#
#   # Create K equally size folds
#   folds <- cut(seq(1, nrow(X)), breaks = Kfolds, labels = FALSE)
#
#   # Perform K fold cross validation
#   mineRules(X, Y, folds = folds, Kfolds = Kfolds)
#
# }
dataTrain <- "../data/out_portugal_2013_nc.csv"
dataTest <- "../data/out_portugal_2017_complete_nc.csv"
atributes = c(34,36,38,40,42,44:47,49,51,53,55,57,59,61,63:65,68)
rankings = c(3,4,11,15,29)
is2Years <- T
outTrain <- read.csv(dataTrain, sep = ";", stringsAsFactors=FALSE, fileEncoding="latin1")
outColNames <- colnames(outTrain)
outTrain <- apply(outTrain, 1, function(line){
cds <- c(4:7, 16:20)
line[4] <- max(as.numeric(line[cds]))
psd <- c(15:24)
line[15] <- max(as.numeric(line[psd]))
as.numeric(line)
})
outTrain <- t(outTrain)
colnames(outTrain) <- outColNames
outTest <- read.csv(dataTest, sep = ";", stringsAsFactors=FALSE, fileEncoding="latin1")
Y <- outTrain[,rankings]
Y <- t(apply(-Y, 1, rank, ties.method = "min"))
Y <- as.matrix(Y)
ys <- outTest[,rankings]
ys <- t(apply(-ys, 1, rank, ties.method = "min"))
ys <- as.matrix(ys)
X <- outTrain[,atributes]
X <- as.matrix(X)
X[X == "#DIV/0!"] <- 0
X <- apply(X, 2, function(l) as.numeric(l))
xs <- outTest[,atributes]
xs <- as.matrix(xs)
xs[xs == "#DIV/0!"] <- 0
xs <- apply(xs, 2, function(l) as.numeric(l))
residentsTotal <- outTest[,"Residents.Total"]
employeesTotal <- outTest[,"Employees.per.Sector.Total"]
unemploymentTotal <- outTest[,"Unemployment.Total"]
xs[,"X.Residents.0.14"] <- outTest[,"Residents.0.14"]/residentsTotal
xs[,"X.Residents.15.64"] <- outTest[,"Residents.15.64"]/residentsTotal
xs[,"X.Residents.65."] <- outTest[,"Residents.65."]/residentsTotal
xs[,"X.Population.without.Education"] <- outTest[,"Population.without.Education"]/residentsTotal
xs[,"X.Population.with.High.School"] <- outTest[,"Population.with.High.School"]/residentsTotal
xs[,"X.Employees.per.Sector.Agriculture"] <- outTest[,"Employees.per.Sector.Agriculture"]/employeesTotal
xs[,"X.Employees.per.Sector.Extraction.Industries"] <- outTest[,"Employees.per.Sector.Extraction.Industries"]/employeesTotal
xs[,"X.Employees.per.Sector.Transformation.Industries"] <- outTest[,"Employees.per.Sector.Transformation.Industries"]/employeesTotal
xs[,"X.Employees.per.Sector.Construction"] <- outTest[,"Employees.per.Sector.Construction"]/employeesTotal
xs[,"X.Employees.per.Sector.Gross.and.Retails.Markets"] <- outTest[,"Employees.per.Sector.Gross.and.Retails.Markets"]/employeesTotal
xs[,"X.Employees.per.Sector.Administration.and.Services"] <- outTest[,"Employees.per.Sector.Administration.and.Services"]/employeesTotal
xs[,"X.Employees.per.Economic.Sector.Banks"] <- outTest[,"Employees.per.Economic.Sector.Banks"]/employeesTotal
xs[,"X.Employees.per.Economic.Sector.Others"] <- outTest[,"Employees.per.Economic.Sector.Others"]/employeesTotal
xs[,"X.Unemployment..25"] <- outTest[,"Unemployment..25"]/unemploymentTotal
save(X, Y, xs, ys, is2Years, file = "portugal2013_2017_complete.RDATA")
dataTrain <- "../data/out_portugal_2013_nc.csv"
dataTest <- "../data/out_portugal_2017_complete_nc.csv"
atributes = c(34,36,38,40,42,44:47,49,51,53,55,57,59,61,63:65,68)
rankings = c(3,4,11,15,29)
is2Years <- T
outTrain <- read.csv(dataTrain, sep = ";", stringsAsFactors=FALSE, fileEncoding="latin1")
outColNames <- colnames(outTrain)
outTrain <- apply(outTrain, 1, function(line){
cds <- c(4:7, 16:20)
line[4] <- max(as.numeric(line[cds]))
psd <- c(15:24)
line[15] <- max(as.numeric(line[psd]))
as.numeric(line)
})
outTrain <- t(outTrain)
colnames(outTrain) <- outColNames
outTest <- read.csv(dataTest, sep = ";", stringsAsFactors=FALSE, fileEncoding="latin1")
Y <- outTrain[,rankings]
Y <- t(apply(-Y, 1, rank, ties.method = "min"))
Y <- as.matrix(Y)
ys <- outTest[,rankings]
ys <- t(apply(-ys, 1, rank, ties.method = "min"))
ys <- as.matrix(ys)
X <- outTrain[,atributes]
X <- as.matrix(X)
X[X == "#DIV/0!"] <- 0
X <- apply(X, 2, function(l) as.numeric(l))
xs <- outTest[,atributes]
xs <- as.matrix(xs)
xs[xs == "#DIV/0!"] <- 0
xs <- apply(xs, 2, function(l) as.numeric(l))
residentsTotal <- outTest[,"Residents.Total"]
employeesTotal <- outTest[,"Employees.per.Sector.Total"]
unemploymentTotal <- outTest[,"Unemployment.Total"]
xs[,"X.Residents.0.14"] <- outTest[,"Residents.0.14"]/residentsTotal
xs[,"X.Residents.15.64"] <- outTest[,"Residents.15.64"]/residentsTotal
xs[,"X.Residents.65."] <- outTest[,"Residents.65."]/residentsTotal
xs[,"X.Population.without.Education"] <- outTest[,"Population.without.Education"]/residentsTotal
xs[,"X.Population.with.High.School"] <- outTest[,"Population.with.High.School"]/residentsTotal
xs[,"X.Employees.per.Sector.Agriculture"] <- outTest[,"Employees.per.Sector.Agriculture"]/employeesTotal
xs[,"X.Employees.per.Sector.Extraction.Industries"] <- outTest[,"Employees.per.Sector.Extraction.Industries"]/employeesTotal
xs[,"X.Employees.per.Sector.Transformation.Industries"] <- outTest[,"Employees.per.Sector.Transformation.Industries"]/employeesTotal
xs[,"X.Employees.per.Sector.Construction"] <- outTest[,"Employees.per.Sector.Construction"]/employeesTotal
xs[,"X.Employees.per.Sector.Gross.and.Retails.Markets"] <- outTest[,"Employees.per.Sector.Gross.and.Retails.Markets"]/employeesTotal
xs[,"X.Employees.per.Sector.Administration.and.Services"] <- outTest[,"Employees.per.Sector.Administration.and.Services"]/employeesTotal
xs[,"X.Employees.per.Economic.Sector.Banks"] <- outTest[,"Employees.per.Economic.Sector.Banks"]/employeesTotal
xs[,"X.Employees.per.Economic.Sector.Others"] <- outTest[,"Employees.per.Economic.Sector.Others"]/employeesTotal
xs[,"X.Unemployment..25"] <- outTest[,"Unemployment..25"]/unemploymentTotal
save(X, Y, xs, ys, is2Years, file = "portugal2013_2017_complete.RDATA")
View(outTrain)
View(outTest)
