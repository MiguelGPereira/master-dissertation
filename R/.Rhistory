}
# CORE SCRIPT
# dependencies
require("carenR")
library(arules)
source("LRAR/caren.R")
source("LRAR/predictLRAR.R")
source("edira/edira.R")
source("miner.R")
# configurations
isPairwise <- 1
Kfolds <- 10
randomSeed <- 1234
maxPairs <- 2
minSupport <<- 51
minConfidence <- 90
confThreshold <- 0.05
minLift <- 0
minImprovment <- 0.01
#load("german2005.RDATA")
#load("german2009.RDATA")
#load("german2005_2009.RDATA")
#load("portugal2009.RDATA")
#load("portugal2013.RDATA")
#load("portugal2009_2013.RDATA")
#load("portugal2013_2017.RDATA")
load("label ranking data/bodyfat.RDATA")
is2Years <- 0
X <- x
Y <- y
# x <- X[1:20,]
# y <- Y[1:20,]
# DISC <- mdlp.rank(x, y, method = "kendall")
# indexesDiscretized <- apply(DISC$Disc.data, 2, function(dc) any(dc==2, na.rm=TRUE))
# # equal width
# if(sum(!indexesDiscretized) > 0){
#   D <- list()
#   nbins <- 4
#   xnd <- as.matrix(x[,!indexesDiscretized])
#   #browser()
#   D$Disc.data <- apply(xnd, 2, discretize, "interval", nbins, 1:nbins)
#   #browser()
#   D$Disc.data <- apply(D$Disc.data, 2, as.integer)
#   D$cutp <- lapply(1:ncol(xnd), function(i){
#     discretize(xnd[,i], "interval", nbins, 1:nbins, onlycuts=TRUE)[-c(1,(nbins+1))]
#   })
#
#   DISC$Disc.data[,!indexesDiscretized] <- D$Disc.data
#   DISC$cutp[!indexesDiscretized] <- D$cutp
#   indexesDiscretized <- apply(DISC$Disc.data, 2, function(dc) any(dc==2, na.rm=TRUE))
# }
# #prune columns with no partitions
# DISC$Disc.data <- DISC$Disc.data[,indexesDiscretized, drop = FALSE]
# if (ncol(DISC$Disc.data) == 0)
# {
#   print("Not discretized")
#   xs <- NULL
# } else {
#   xs <- sapply(which(indexesDiscretized), function(j){
#     findInterval(xs[,j], c(-Inf, DISC$cutp[[j]], Inf) )
#   })
# }
# # transform in unique attributes
# unique.attributes <- function(train.matrix, class, test.matrix, npart)
# {
#   mx <- c(0, cumsum(apply(train.matrix, 2, max))[-ncol(train.matrix)])
#
#   list( cbind( t(t(train.matrix) + as.vector(mx)), class ), t(t(test.matrix) + mx) , npart = npart)
# }
#
# if(!is.null(xs)){
#   npart <- mean(apply(DISC$Disc.data, 2, function(c) length(unique(c))))
#   res <- unique.attributes(DISC$Disc.data, class, xs, npart)
#
# } else {
#   res <- NULL
# }
# xs <-res[[2]]
# xd <-res[[1]]
# rulz <- aflrC7Pairwise(xd, y, msup = minSupport, mconf = minConfidence, mlift = minLift, mimp = minImprovment,
#                        theta = 0, Xmx = "2000M", confThreshold = confThreshold)
# invoke miner
if(is2Years){
mineRules(X, Y, is2Years, xs = xs, ys = ys)
} else {
# KFold Cross Validation
# Randomly shuffle the data
set.seed(randomSeed)
samplerows <- sample(nrow(X))
X <- X[samplerows, ]
Y <- Y[samplerows, ]
# Create K equally size folds
folds <- cut(seq(1, nrow(X)), breaks = Kfolds, labels = FALSE)
# Perform K fold cross validation
#mineRules(X, Y, folds = folds, Kfolds = Kfolds)
repeat{
exception <- FALSE
result = tryCatch({
mineRules(X, Y, folds = folds, Kfolds = Kfolds)
}, error = function(e) {
if(e$message == "subscript out of bounds" &&  e$call == "FUN(X[[i]], ...)"){
if(minSupport == 1) {
print("#no rules found!")
exception <- TRUE
} else {
print(paste("#no rules found - decreasing support from ",minSupport," to ",minSupport - 5))
minSupport <<- minSupport - 5
e
}
} else {
print("#error")
print(e)
exception <- TRUE
}
}, finally = {})
if( !inherits(result, "error") || (inherits(result, "error") && exception) ){
break()
}
}
}
load("label ranking data/authorship.RDATA")
# CORE SCRIPT
# dependencies
require("carenR")
library(arules)
source("LRAR/caren.R")
source("LRAR/predictLRAR.R")
source("edira/edira.R")
source("miner.R")
# configurations
isPairwise <- 1
Kfolds <- 10
randomSeed <- 1234
maxPairs <- 2
minSupport <<- 51
minConfidence <- 90
confThreshold <- 0.05
minLift <- 0
minImprovment <- 0.01
#load("german2005.RDATA")
#load("german2009.RDATA")
#load("german2005_2009.RDATA")
#load("portugal2009.RDATA")
#load("portugal2013.RDATA")
#load("portugal2009_2013.RDATA")
#load("portugal2013_2017.RDATA")
load("label ranking data/authorship.RDATA")
is2Years <- 0
X <- x
Y <- y
# x <- X[1:20,]
# y <- Y[1:20,]
# DISC <- mdlp.rank(x, y, method = "kendall")
# indexesDiscretized <- apply(DISC$Disc.data, 2, function(dc) any(dc==2, na.rm=TRUE))
# # equal width
# if(sum(!indexesDiscretized) > 0){
#   D <- list()
#   nbins <- 4
#   xnd <- as.matrix(x[,!indexesDiscretized])
#   #browser()
#   D$Disc.data <- apply(xnd, 2, discretize, "interval", nbins, 1:nbins)
#   #browser()
#   D$Disc.data <- apply(D$Disc.data, 2, as.integer)
#   D$cutp <- lapply(1:ncol(xnd), function(i){
#     discretize(xnd[,i], "interval", nbins, 1:nbins, onlycuts=TRUE)[-c(1,(nbins+1))]
#   })
#
#   DISC$Disc.data[,!indexesDiscretized] <- D$Disc.data
#   DISC$cutp[!indexesDiscretized] <- D$cutp
#   indexesDiscretized <- apply(DISC$Disc.data, 2, function(dc) any(dc==2, na.rm=TRUE))
# }
# #prune columns with no partitions
# DISC$Disc.data <- DISC$Disc.data[,indexesDiscretized, drop = FALSE]
# if (ncol(DISC$Disc.data) == 0)
# {
#   print("Not discretized")
#   xs <- NULL
# } else {
#   xs <- sapply(which(indexesDiscretized), function(j){
#     findInterval(xs[,j], c(-Inf, DISC$cutp[[j]], Inf) )
#   })
# }
# # transform in unique attributes
# unique.attributes <- function(train.matrix, class, test.matrix, npart)
# {
#   mx <- c(0, cumsum(apply(train.matrix, 2, max))[-ncol(train.matrix)])
#
#   list( cbind( t(t(train.matrix) + as.vector(mx)), class ), t(t(test.matrix) + mx) , npart = npart)
# }
#
# if(!is.null(xs)){
#   npart <- mean(apply(DISC$Disc.data, 2, function(c) length(unique(c))))
#   res <- unique.attributes(DISC$Disc.data, class, xs, npart)
#
# } else {
#   res <- NULL
# }
# xs <-res[[2]]
# xd <-res[[1]]
# rulz <- aflrC7Pairwise(xd, y, msup = minSupport, mconf = minConfidence, mlift = minLift, mimp = minImprovment,
#                        theta = 0, Xmx = "2000M", confThreshold = confThreshold)
# invoke miner
if(is2Years){
mineRules(X, Y, is2Years, xs = xs, ys = ys)
} else {
# KFold Cross Validation
# Randomly shuffle the data
set.seed(randomSeed)
samplerows <- sample(nrow(X))
X <- X[samplerows, ]
Y <- Y[samplerows, ]
# Create K equally size folds
folds <- cut(seq(1, nrow(X)), breaks = Kfolds, labels = FALSE)
# Perform K fold cross validation
#mineRules(X, Y, folds = folds, Kfolds = Kfolds)
repeat{
exception <- FALSE
result = tryCatch({
mineRules(X, Y, folds = folds, Kfolds = Kfolds)
}, error = function(e) {
if(e$message == "subscript out of bounds" &&  e$call == "FUN(X[[i]], ...)"){
if(minSupport == 1) {
print("#no rules found!")
exception <- TRUE
} else {
print(paste("#no rules found - decreasing support from ",minSupport," to ",minSupport - 5))
minSupport <<- minSupport - 5
e
}
} else {
print("#error")
print(e)
exception <- TRUE
}
}, finally = {})
if( !inherits(result, "error") || (inherits(result, "error") && exception) ){
break()
}
}
}
# CORE SCRIPT
# dependencies
require("carenR")
library(arules)
source("LRAR/caren.R")
source("LRAR/predictLRAR.R")
source("edira/edira.R")
source("miner.R")
# configurations
isPairwise <- 1
Kfolds <- 10
randomSeed <- 1234
maxPairs <- 2
minSupport <<- 20
minConfidence <- 90
confThreshold <- 0.05
minLift <- 0
minImprovment <- 0.01
#load("german2005.RDATA")
#load("german2009.RDATA")
#load("german2005_2009.RDATA")
#load("portugal2009.RDATA")
#load("portugal2013.RDATA")
#load("portugal2009_2013.RDATA")
#load("portugal2013_2017.RDATA")
load("label ranking data/authorship.RDATA")
is2Years <- 0
X <- x
Y <- y
# invoke miner
if(is2Years){
mineRules(X, Y, is2Years, xs = xs, ys = ys)
} else {
# KFold Cross Validation
# Randomly shuffle the data
set.seed(randomSeed)
samplerows <- sample(nrow(X))
X <- X[samplerows, ]
Y <- Y[samplerows, ]
# Create K equally size folds
folds <- cut(seq(1, nrow(X)), breaks = Kfolds, labels = FALSE)
# Perform K fold cross validation
#mineRules(X, Y, folds = folds, Kfolds = Kfolds)
repeat{
exception <- FALSE
result = tryCatch({
mineRules(X, Y, folds = folds, Kfolds = Kfolds)
}, error = function(e) {
if(e$message == "subscript out of bounds" &&  e$call == "FUN(X[[i]], ...)"){
if(minSupport == 1) {
print("#no rules found!")
exception <- TRUE
} else {
print(paste("#no rules found - decreasing support from ",minSupport," to ",minSupport - 5))
minSupport <<- minSupport - 5
e
}
} else {
print("#error")
print(e)
exception <- TRUE
}
}, finally = {})
if( !inherits(result, "error") || (inherits(result, "error") && exception) ){
break()
}
}
}
# CORE SCRIPT
# dependencies
require("carenR")
library(arules)
source("LRAR/caren.R")
source("LRAR/predictLRAR.R")
source("edira/edira.R")
source("miner.R")
# configurations
isPairwise <- 1
Kfolds <- 10
randomSeed <- 1234
maxPairs <- 2
minSupport <<- 20
minConfidence <- 90
confThreshold <- 0.05
minLift <- 0
minImprovment <- 0.01
#load("german2005.RDATA")
#load("german2009.RDATA")
#load("german2005_2009.RDATA")
#load("portugal2009.RDATA")
#load("portugal2013.RDATA")
#load("portugal2009_2013.RDATA")
#load("portugal2013_2017.RDATA")
load("label ranking data/stock.RDATA")
is2Years <- 0
X <- x
Y <- y
# invoke miner
if(is2Years){
mineRules(X, Y, is2Years, xs = xs, ys = ys)
} else {
# KFold Cross Validation
# Randomly shuffle the data
set.seed(randomSeed)
samplerows <- sample(nrow(X))
X <- X[samplerows, ]
Y <- Y[samplerows, ]
# Create K equally size folds
folds <- cut(seq(1, nrow(X)), breaks = Kfolds, labels = FALSE)
# Perform K fold cross validation
#mineRules(X, Y, folds = folds, Kfolds = Kfolds)
repeat{
exception <- FALSE
result = tryCatch({
mineRules(X, Y, folds = folds, Kfolds = Kfolds)
}, error = function(e) {
if(e$message == "subscript out of bounds" &&  e$call == "FUN(X[[i]], ...)"){
if(minSupport == 1) {
print("#no rules found!")
exception <- TRUE
} else {
print(paste("#no rules found - decreasing support from ",minSupport," to ",minSupport - 5))
minSupport <<- minSupport - 5
e
}
} else {
print("#error")
print(e)
exception <- TRUE
}
}, finally = {})
if( !inherits(result, "error") || (inherits(result, "error") && exception) ){
break()
}
}
}
# CORE SCRIPT
# dependencies
require("carenR")
library(arules)
source("LRAR/caren.R")
source("LRAR/predictLRAR.R")
source("edira/edira.R")
source("miner.R")
# configurations
isPairwise <- 1
Kfolds <- 10
randomSeed <- 1234
maxPairs <- 2
minSupport <<- 20
minConfidence <- 90
confThreshold <- 0.05
minLift <- 0
minImprovment <- 0.01
#load("german2005.RDATA")
#load("german2009.RDATA")
#load("german2005_2009.RDATA")
#load("portugal2009.RDATA")
#load("portugal2013.RDATA")
#load("portugal2009_2013.RDATA")
#load("portugal2013_2017.RDATA")
load("label ranking data/calhousing.RDATA")
is2Years <- 0
X <- x
Y <- y
# invoke miner
if(is2Years){
mineRules(X, Y, is2Years, xs = xs, ys = ys)
} else {
# KFold Cross Validation
# Randomly shuffle the data
set.seed(randomSeed)
samplerows <- sample(nrow(X))
X <- X[samplerows, ]
Y <- Y[samplerows, ]
# Create K equally size folds
folds <- cut(seq(1, nrow(X)), breaks = Kfolds, labels = FALSE)
# Perform K fold cross validation
#mineRules(X, Y, folds = folds, Kfolds = Kfolds)
repeat{
exception <- FALSE
result = tryCatch({
mineRules(X, Y, folds = folds, Kfolds = Kfolds)
}, error = function(e) {
if(e$message == "subscript out of bounds" &&  e$call == "FUN(X[[i]], ...)"){
if(minSupport == 1) {
print("#no rules found!")
exception <- TRUE
} else {
print(paste("#no rules found - decreasing support from ",minSupport," to ",minSupport - 5))
minSupport <<- minSupport - 5
e
}
} else {
print("#error")
print(e)
exception <- TRUE
}
}, finally = {})
if( !inherits(result, "error") || (inherits(result, "error") && exception) ){
break()
}
}
}
# CORE SCRIPT
# dependencies
require("carenR")
library(arules)
source("LRAR/caren.R")
source("LRAR/predictLRAR.R")
source("edira/edira.R")
source("miner.R")
# configurations
isPairwise <- 1
Kfolds <- 10
randomSeed <- 1234
maxPairs <- 2
minSupport <<- 20
minConfidence <- 90
confThreshold <- 0.05
minLift <- 0
minImprovment <- 0.01
#load("german2005.RDATA")
#load("german2009.RDATA")
#load("german2005_2009.RDATA")
#load("portugal2009.RDATA")
#load("portugal2013.RDATA")
#load("portugal2009_2013.RDATA")
#load("portugal2013_2017.RDATA")
load("label ranking data/segment.RDATA")
is2Years <- 0
X <- x
Y <- y
# invoke miner
if(is2Years){
mineRules(X, Y, is2Years, xs = xs, ys = ys)
} else {
# KFold Cross Validation
# Randomly shuffle the data
set.seed(randomSeed)
samplerows <- sample(nrow(X))
X <- X[samplerows, ]
Y <- Y[samplerows, ]
# Create K equally size folds
folds <- cut(seq(1, nrow(X)), breaks = Kfolds, labels = FALSE)
# Perform K fold cross validation
#mineRules(X, Y, folds = folds, Kfolds = Kfolds)
repeat{
exception <- FALSE
result = tryCatch({
mineRules(X, Y, folds = folds, Kfolds = Kfolds)
}, error = function(e) {
if(e$message == "subscript out of bounds" &&  e$call == "FUN(X[[i]], ...)"){
if(minSupport == 1) {
print("#no rules found!")
exception <- TRUE
} else {
print(paste("#no rules found - decreasing support from ",minSupport," to ",minSupport - 5))
minSupport <<- minSupport - 5
e
}
} else {
print("#error")
print(e)
exception <- TRUE
}
}, finally = {})
if( !inherits(result, "error") || (inherits(result, "error") && exception) ){
break()
}
}
}
